#include <iostream>
#include <cstdlib>

// Определяем длину массива в виде вставки LN со значением 10
#define LN 10


// Используем поле имен std для удобства вывода
using namespace std;


// Объявляем прототипы функций
void init_array(double*);
void show(double*);
void qsort(double*, int);


int main()
{
    double* arr;
    arr = new double[LN];
    init_array(arr);

    show(arr);
    qsort(arr, LN);
    show(arr);

    delete[] arr;
    return EXIT_SUCCESS;
}


void qsort(double* arr, int N)
{
    /*
     *
     * Функция быстрой сортировки массива. Работает рекурсивно.
     * Принимает на вход:
     *      double* arr - Указатель на область памяти сортируемого массива
     *      int N       - Количество элементов в последовательности
     *
     */
    int i = 0;                   // Индекс первого элемента
    int j = N - 1;               // Индекс последнего элемента

    double pivot = arr[N / 2];   // Опорный элемент текущего массива

    // Цикл разделяющий переданный массив на 2 части
    do{
        // Пробегаем элементы, ищем те, которые нужно перекинуть в другую часть
        // В левой части массива пропускаем(оставляем на месте) элементы, которые меньше центрального

        // Пропускаем все элементы которые меньше опорного, идем слева
        while(arr[i] < pivot) i++;

        // Пропускаем все элементы которые больше опорного, идем справа
        while(arr[j] > pivot) j--;

        // В итоге i - индекс первого элемента, больше опорного, слева
        // j - индекс первого элемента, меньше опорного, справа

        // Меняем элементы в позициях i, j, местами
        if (i <= j)
        {
            swap(arr[i], arr[j]);
            i++;
            j--;
        }
    }while (i <= j); // Повторяем операцию пока i и j не встретятся в одной точке массива

    // В итоге формируется массив разделенный на две части [0, j + 1] [i, N - i].
    // В правой части все элементы больше опорного, в левой части все элементы меньше опорного

    // Если j не нулевое, то еще есть что сортировать
    // Рекурсивно вызываем функцию сортировки для левой части массива
    if (j > 0) qsort(arr, j + 1);

    // Если i не вышло за пределы массива или правая часть не нулевая (i != N)
    // значит нам еще есть что сортировать и рекурсивно вызываем функцию
    // Внимание: Первым аргументом идет не весь массив, а ссылка на превый элемент правой части.
    if (i < N) qsort(&arr[i], N - i);
}


void init_array(double* ptr)
{
    /*
     * Функция инициализирующая массив.
     *
     * Принимает на вход:
     *      double* ptr - указатель на первый элемент массива.
     */

    // Массив который мы копируем по адресам переданным указателем.
    double new_arr[LN] = {1., 42., -20., -5.2, -6.43, 2.3, 2.5, 0.0, 0.24, -0.54};
    // Цикл по массиву для инициализации данных.
    for(int i = 0; i < LN; i++)
    {
        ptr[i] = new_arr[i];
    }
}


void show(double* arr)
{
    /*
     * Функция вывода массива в консоль.
     * Принимает на вход:
     *      double* arr - Указатель на область памяти массива.
     */

    cout << "Array: [";
    for(int i = 0; i < LN - 1; i++)
    {
        cout << arr[i] << ", ";
    }
    cout << arr[LN - 1] << "]\n";
}