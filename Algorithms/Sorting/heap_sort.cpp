#include <iostream>
#include <cstdlib>

// Определяем длину массива в виде вставки LN со значением 10
#define LN 10


// Используем поле имен std для удобства вывода
using namespace std;


// Объявляем прототипы функций
void show(double*);
void heap_sort(double*);
void _buildheap(double*);
void _heapify(double*, int, int);
void init_array(double*);


int main()
{
    // Указатель на массив типа double
    double* arr;
    arr = new double[LN];

    // Инициализируем массив числами заданными в функции
    init_array(arr);

    // Выводим массив на экран, сортируем и снова выводим на экран
    show(arr);
    heap_sort(arr);
    show(arr);

    delete[] arr;
    return EXIT_SUCCESS;
}


void init_array(double* ptr)
{
    /*
     * Функция инициализирующая массив.
     *
     * Принимает на вход:
     *      double* ptr - указатель на первый элемент массива.
     */

    // Массив который мы копируем по адресам переданным указателем.
    double new_arr[LN] = {1., 42., -20., -5.2, -6.43, 2.3, 2.5, 0.0, 0.24, -0.54};
    // Цикл по массиву для инициализации данных.
    for(int i = 0; i < LN; i++)
    {
        ptr[i] = new_arr[i];
    }
}


void _buildheap(double* arr)
{
    /*
     *
     * Алгоритм построения кучи из массива.
     * Принимает на вход:
     *      double* arr - Указатель на область памяти изменяемого массива.
     *
     */


    for(int i = LN / 2 - 1; i >= 0; i--)
    {
        _heapify(arr, i, LN);   // Переупорядочивание поддерева
    }
}


void _heapify(double* arr, int idx, int n)
{
    /*
     *
     * Функция переупорядочивающая поддерево с корнем в узле idx и максимальным номером
     * элемента не больше n
     * Принимает на вход:
     *      double* arr   - Указатель на область памяти изменяемого массива.
     *      int idx       - Индекс корневого узла поддерева
     *      int n         - Максимальный элемент поддерева
     *
     */


    int largest = idx;        // Индекс наибольшего элемента
    int left = 2 * idx + 1;   // Индекс левого потомка
    int right = 2 * idx + 2;  // Индекс правого потомка

    // Если индекс левого потомка не превышает индекс максимального элемента
    // и значение в левом узле больше, чем значение в корневом узле, то присваиваем largest индекс левого узла
    if ((left < n) and (arr[left] > arr[idx])) largest = left;

    // Если индекс правого потомка не превышает индекс максимального элемента
    // и значение в правом узле больше, чем значение в корневом узле, то присваиваем largest индекс правого узла
    if ((right < n) and (arr[right] > arr[largest])) largest = right;

    // Если индекс максимального элемента не совпадает с индексом корневого производим замену позиций idx & largest
    if (largest != idx)
    {
        swap(arr[idx], arr[largest]);    // Замена позиций
        _heapify(arr, largest, n);             // Рекурсивный проход по поддереву потомка
    }
}


void heap_sort(double* arr)
{
    /*
     *
     * Алгоритм сортировки кучей(пирамидальной сортировки).
     * Принимает на вход:
     *      double* arr - Указатель на область памяти сортируемого массива.
     *
     */

    _buildheap(arr);               // Построение max-кучи из исходного массива

    for(int i= LN - 1; i >= 0; i--)
    {
        swap(arr[0], arr[i]); // Ставим наибольший элемент в конец.
        _heapify(arr, 0, i);    // Перестраиваем кучу в диапазоне от 0 до i, то есть все кроме измененного и выше
    }
}


void show(double* arr){
    /*
     * Функция вывода массива в консоль.
     * Принимает на вход:
     *      double* arr - Указатель на область памяти массива.
     */

    cout << "Array: [";

    for(int i=0; i < LN - 1; i++)
    {
        cout << arr[i] << ", ";
    }

    cout << arr[LN - 1] << "]\n";
}